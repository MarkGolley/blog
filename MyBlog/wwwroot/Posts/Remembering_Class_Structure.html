<!-- PublishedDate: 2025-5-21 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: auto;
            padding: 2rem;
            line-height: 1.6;
            background: #f9f9f9;
            color: #333;
        }
        h1, h2 {
            color: #222;
        }
        h3 {
            font-size: 1.1rem;
            color: #555;
            font-weight: 600;
            margin-top: 1.2rem;
            margin-bottom: 0.6rem;
        }
        h4 {
            font-size: 1rem;
            color: #666;
            font-weight: 600;
            font-style: italic;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        pre {
            background: #eee;
            padding: 1rem;
            overflow-x: auto;
        }
        code {
            font-family: monospace;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .tip {
            background: #e7f3ff;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1rem 0;
        }
        .blueprint {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 1rem;
            margin: 1rem 0;
            font-family: monospace;
            white-space: pre;
        }
    </style>
</head>
<body>
<h1>C# Class Structure: A Developer's Memory Guide</h1>

<p>As developers, we all face that nagging feeling: "I think I know how to code, but can I remember correct class structure? No I cant!" The struggle is real.</p>

<p>In this post I'll share a framework to help remember C# class structure.</p>

<h2>Why Class Structure Matters</h2>
<p>Before diving in let's remember why correct class structure matters:</p>

<ol>
    <li><strong>Readability</strong>: easier to read/understand</li>
    <li><strong>Maintenance</strong>: easier to find and fix issues</li>
    <li><strong>Professionalism</strong>: demonstrates technical proficiency</li>
</ol>

<h2>The UNC-SFICN Framework: Remembering C# Class Structure</h2>

<p>To help remember the order of structure in a C# class, here is a memory tool called "UNC-SFICN", in my head i'm calling this 'Uncle Sficin' like a long lost Scandinavian uncle:</p>

<h3>U - Usings <span style="font-size: small; font-weight: normal;">- File imports/references</span></h3>
<h3>N - Namespace declaration</h3>
<h3>C - Class declaration <span style="font-size: small; font-weight: normal;">- Including attributes and XML documentation</span></h3>
<h3>S - Statics <span style="font-size: small; font-weight: normal;">- Constants, Static Fields, Static Properties, Static Events and Static Methods</span></h3>
<h3>F - Fields <span style="font-size: small; font-weight: normal;">(instance fields only)</span></h3>
<h3>I - Initialization <span style="font-size: small; font-weight: normal;">(constructors)</span></h3>
<h3>C - Class behaviors <span style="font-size: small; font-weight: normal;">- Instance Properties, Events and Methods</span></h3>
<h3>N - Nested types <span style="font-size: small; font-weight: normal;">(inner classes, structs, interfaces, enums)</span></h3>

<p>Here's a breakdown:</p>

<h2>U - Usings</h2>

<p>Start with all your using directives, organized from system to custom:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using MyCompany.Services;
using MyCompany.Utilities;</code></pre>

<h2>N - Namespace Declaration</h2>

<p>Declare your namespace to organize your types:</p>

<pre><code>namespace MyCompany.Processors
{
    // Everything else goes inside here
}</code></pre>

<h2>C - Class Declaration</h2>

<p>Define your class, including any documentation and attributes:</p>

<pre><code>/// &lt;summary&gt;
/// Processes orders through the payment gateway
/// &lt;/summary&gt;
[Serializable]
public class OrderProcessor
{
    // Class members will go here
}</code></pre>

<h2>S - Static Items (constants, fields, properties, events, and methods)</h2>

<p>Constants and static members should appear first within your class:</p>

<h4>1. Constants (values that can't change)</h4>
<pre><code>public const string OrderPrefix = "ORD";
protected const int MaxProcessingAttempts = 3;
private const decimal MinimumOrderAmount = 5.00m;</code></pre>

<h4>2. Static fields (belong to the class, not instances)</h4>
<pre><code>public static readonly TimeSpan ProcessingTimeout = TimeSpan.FromMinutes(5);
private static readonly string s_processorId = Guid.NewGuid().ToString();</code></pre>

<h4>3. Static properties</h4>
<pre><code>public static bool IsServiceAvailable { get; private set; }</code></pre>

<h2>F - Fields (Instance)</h2>

<p>List your instance fields, maintaining the access modifier order (public to private):</p>

<pre><code>protected readonly string _merchantId;
private readonly IPaymentGateway _paymentGateway;
private bool _isProcessing;</code></pre>

<h2>I - Initialization (Constructors)</h2>

<p>Group your constructors together, starting with the most general:</p>

<pre><code>public OrderProcessor()
{
    // Default constructor
}

public OrderProcessor(IPaymentGateway paymentGateway, string merchantId)
{
    _paymentGateway = paymentGateway;
    _merchantId = merchantId;
}</code></pre>

<h2>C - Class Behaviors (Instance Properties, Events, Methods)</h2>

<p>Next come the properties, events, and methods that define your class's behavior:</p>

<h4>1. Properties</h4>
<pre><code>public string Status { get; private set; } = "Ready";
public int Priority { get; set; } = 1;</code></pre>

<h4>2. Events</h4>
<pre><code>public event EventHandler&lt;OrderProcessedEventArgs&gt; OrderProcessed;</code></pre>

<h4>3. Methods</h4>
<pre><code>public async Task&lt;bool&gt; ProcessOrderAsync(Order order)
{
    // Method implementation
}</code></pre>

<h2>N - Nested Types</h2>

<p>Finally, include any nested types that belong specifically to this class:</p>

<pre><code>private class OrderProcessingResult
{
    public bool Success { get; set; }
    public string TransactionId { get; set; }
}

public enum OrderStatus
{
    Pending,
    Processing,
    Complete,
    Failed
}</code></pre>

<h2>Access Modifier Order</h2>

<p>To wrap up, its worth clarifying the order members by their access modifier from most accessible to least accessible:</p>

<ol>
    <li><code>public</code> - Accessible by any code</li>
    <li><code>protected</code> - Accessible by the class and its subclasses</li>
    <li><code>internal</code> - Accessible within the same assembly</li>
    <li><code>protected internal</code> - Accessible by the assembly or derived classes</li>
    <li><code>private protected</code> - Accessible by derived classes within the same assembly</li>
    <li><code>private</code> - Accessible only within the declaring class</li>
</ol>

<p>Hopefully this helps make things a little clearer than before!</p>
</body>
</html>
