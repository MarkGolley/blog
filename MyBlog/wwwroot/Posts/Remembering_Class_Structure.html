<!-- PublishedDate: 2025-5-21 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <title>C# Class Structure: A Developer's Memory Guide</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../wwwroot/css/blogs.css">
</head>
<body>
<h1>C# Class Structure: A Developer's Memory Guide</h1>

<p>As developers, we all face that nagging feeling: "I think I know how to code, but can I remember correct class structure? No I cant!" The struggle is real.</p>

<p>In this post I'll share a framework to help remember C# class structure.</p>

<h2>Why Class Structure Matters</h2>
<p>Before diving in let's remember why correct class structure matters:</p>

<ol>
    <li><strong>Readability</strong>: easier to read/understand</li>
    <li><strong>Maintenance</strong>: easier to find and fix issues</li>
    <li><strong>Professionalism</strong>: demonstrates technical proficiency</li>
</ol>

<h2>The UNC-SFICN Framework: Remembering C# Class Structure</h2>

<p>To help remember the order of structure in a C# class, here is a memory tool called "UNC-SFICN", in my head i'm calling this 'Uncle Sficin' like a long lost Scandinavian uncle:</p>

<h3>U - Usings <span style="font-size: small; font-weight: normal;">- File imports/references</span></h3>
<h3>N - Namespace declaration</h3>
<h3>C - Class declaration <span style="font-size: small; font-weight: normal;">- Including attributes and XML documentation</span></h3>
<h3>S - Statics <span style="font-size: small; font-weight: normal;">- Constants, Static Fields, Static Properties, Static Events and Static Methods</span></h3>
<h3>F - Fields <span style="font-size: small; font-weight: normal;">(instance fields only)</span></h3>
<h3>I - Initialization <span style="font-size: small; font-weight: normal;">(constructors)</span></h3>
<h3>C - Class behaviors <span style="font-size: small; font-weight: normal;">- Instance Properties, Events and Methods</span></h3>
<h3>N - Nested types <span style="font-size: small; font-weight: normal;">(inner classes, structs, interfaces, enums)</span></h3>

<p>Here's a breakdown:</p>

<h2>U - Usings</h2>

<p>Start with all your using directives, organized from system to custom:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using MyCompany.Services;
using MyCompany.Utilities;</code></pre>

<h2>N - Namespace Declaration</h2>

<p>Declare your namespace to organize your types:</p>

<pre><code>namespace MyCompany.Core
{
    // Everything else goes inside here
}</code></pre>

<h2>C - Class Declaration</h2>

<p>Define your class, including any documentation and attributes:</p>

<pre><code>/// docs
public class DataManager : IDataProcessor
{
    // Class members go here
}</code></pre>

<h2>S - Statics</h2>

<p>Define static members, starting with constants, then fields, properties and methods:</p>

<pre><code>// Constants
public const string DefaultConnectionString = "";

// Static fields
private static readonly HttpClient _httpClient = new HttpClient();

// Static properties
public static TimeSpan DefaultTimeout { get; set; } = TimeSpan.FromSeconds(30);

// Static methods
public static bool IsValidConfiguration(Configuration config)
{
    // method logic here
}</code></pre>

<h2>F - Fields</h2>

<p>Define instance fields, often private or protected:</p>

<pre><code>// Private fields
protected readonly ILogger _logger;
private readonly IRepository _repository;
private bool _isInitialized;</code></pre>

<h2>I - Initialization</h2>

<p>Define constructors and any initialization logic:</p>

<pre><code>// Main constructor
public DataManager(IRepository repository, ILogger logger)
{
// Initialization logic here
}

// Parameterless constructor
public DataManager() : this(new DefaultRepository(), LogManager.GetCurrentClassLogger())
{
}</code></pre>

<h2>C - Class Behaviors</h2>

<p>Define instance properties, events, and methods:</p>

<pre><code>// Properties
public bool IsConnected { get; private set; }
public ConnectionStatus Status => _isInitialized ? ConnectionStatus.Ready : ConnectionStatus.Pending;

// Methods
public async Task&lt;DataResult&gt; ProcessDataAsync(DataRequest request)
{
// method logic here
}
</code></pre>

<h2>N - Nested Types</h2>

<p>Define any nested types like enums, classes, interfaces:</p>

<pre><code>// Nested enum
public enum ConnectionStatus
{
    Pending,
    Ready,
    Failed
}

// Nested class
private class DataRequestValidator
{
    public bool Validate(DataRequest request)
    {
        // method logic here
    }
}</code></pre>


<h2>Access Modifier Order</h2>

<p>To wrap up, its worth clarifying the order members by their access modifier from most accessible to least accessible:</p>

<ol>
    <li><code>public</code> - Accessible by any code</li>
    <li><code>protected</code> - Accessible by the class and its subclasses</li>
    <li><code>internal</code> - Accessible within the same assembly</li>
    <li><code>protected internal</code> - Accessible by the assembly or derived classes</li>
    <li><code>private protected</code> - Accessible by derived classes within the same assembly</li>
    <li><code>private</code> - Accessible only within the declaring class</li>
</ol>

<p>Hopefully this helps make things a little clearer than before!</p>
</body>
</html>
