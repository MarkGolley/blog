<!-- PublishedDate: 2025-5-21 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: auto;
            padding: 2rem;
            line-height: 1.6;
            background: #f9f9f9;
            color: #333;
        }
        h1, h2 {
            color: #222;
        }
        h3 {
            font-size: 1.1rem;
            color: #555;
            font-weight: 600;
            margin-top: 1.2rem;
            margin-bottom: 0.6rem;
        }
        h4 {
            font-size: 1rem;
            color: #666;
            font-weight: 600;
            font-style: italic;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
        }

        pre {
            background: #eee;
            padding: 1rem;
            overflow-x: auto;
        }
        code {
            font-family: monospace;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .tip {
            background: #e7f3ff;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1rem 0;
        }
        .blueprint {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 1rem;
            margin: 1rem 0;
            font-family: monospace;
            white-space: pre;
        }
    </style>
</head>
<body>
<h1>C# Class Structure: A Developer's Memory Guide</h1>

<p>As developers, we all face that nagging feeling: "I think I know how to code, but can I remember correct class structure? No I cant!" The struggle is real.</p>

<p>In this post I'll share a framework to help remember C# class structure.</p>

<h2>Why Class Structure Matters</h2>
<p>Before diving in let's remember why correct class structure matters:</p>

<ol>
    <li><strong>Readability</strong>: easier to read/understand</li>
    <li><strong>Maintenance</strong>: easier to find and fix issues</li>
    <li><strong>Professionalism</strong>: demonstrates technical proficiency</li>
</ol>

<h2>The UNC-SFICN Framework: Remembering C# Class Structure</h2>

<p>To help remember the order of structure in a C# class, here is a memory tool called "UNC-SFICN", in my head i'm calling this 'Uncle Sficin' like a long lost Scandinavian uncle:</p>

<h3>U - Usings <span style="font-size: small; font-weight: normal;">- File imports/references</span></h3>
<h3>N - Namespace declaration</h3>
<h3>C - Class declaration <span style="font-size: small; font-weight: normal;">- Including attributes and XML documentation</span></h3>
<h3>S - Statics <span style="font-size: small; font-weight: normal;">- Constants, Static Fields, Static Properties, Static Events and Static Methods</span></h3>
<h3>F - Fields <span style="font-size: small; font-weight: normal;">(instance fields only)</span></h3>
<h3>I - Initialization <span style="font-size: small; font-weight: normal;">(constructors)</span></h3>
<h3>C - Class behaviors <span style="font-size: small; font-weight: normal;">- Instance Properties, Events and Methods</span></h3>
<h3>N - Nested types <span style="font-size: small; font-weight: normal;">(inner classes, structs, interfaces, enums)</span></h3>

<p>Here's a breakdown:</p>

<h2>U - Usings</h2>

<p>Start with all your using directives, organized from system to custom:</p>

<pre><code>using System;
using System.Collections.Generic;
using System.Linq;
using MyCompany.Services;
using MyCompany.Utilities;</code></pre>

<h2>N - Namespace Declaration</h2>

<p>Declare your namespace to organize your types:</p>

<pre><code>namespace MyCompany.Core
{
    // Everything else goes inside here
}</code></pre>

<h2>C - Class Declaration</h2>

<p>Define your class, including any documentation and attributes:</p>

<pre><code>/// &lt;summary&gt;
/// Handles data management operations for the application.
/// &lt;/summary&gt;
[Serializable]
public class DataManager : IDataProcessor
{
    // Class members go here
}</code></pre>

<h2>S - Statics</h2>

<p>Define static members, starting with constants, then fields, properties and methods:</p>

<pre><code>// Constants
public const string DefaultConnectionString = "Data Source=localhost;Initial Catalog=AppDb;";

// Static fields
private static readonly HttpClient _httpClient = new HttpClient();

// Static properties
public static TimeSpan DefaultTimeout { get; set; } = TimeSpan.FromSeconds(30);

// Static methods
public static bool IsValidConfiguration(Configuration config)
{
    return !string.IsNullOrEmpty(config.ApiKey) && config.Endpoint != null;
}</code></pre>

<h2>F - Fields</h2>

<p>Define instance fields, often private or protected:</p>

<pre><code>// Private fields
private readonly ILogger _logger;
private readonly IRepository _repository;
private bool _isInitialized;</code></pre>

<h2>I - Initialization</h2>

<p>Define constructors and any initialization logic:</p>

<pre><code>// Main constructor
public DataManager(IRepository repository, ILogger logger)
{
// Initialization logic here
}

// Parameterless constructor
public DataManager() : this(new DefaultRepository(), LogManager.GetCurrentClassLogger())
{
}</code></pre>

<h2>C - Class Behaviors</h2>

<p>Define instance properties, events, and methods:</p>

<pre><code>// Properties
public bool IsConnected { get; private set; }
public ConnectionStatus Status => _isInitialized ? ConnectionStatus.Ready : ConnectionStatus.Pending;

// Methods
public async Task&lt;DataResult&gt; ProcessDataAsync(DataRequest request)
{
// method logic here
}

private async Task ValidateRequestAsync(DataRequest request)
{
// method logic here
}</code></pre>

<h2>N - Nested Types</h2>

<p>Define any nested types like enums, classes, interfaces:</p>

<pre><code>// Nested enum
public enum ConnectionStatus
{
    Pending,
    Ready,
    Failed
}

// Nested class
private class DataRequestValidator
{
    public bool Validate(DataRequest request)
    {
        // method logic here
    }
}</code></pre>


<h2>Access Modifier Order</h2>

<p>To wrap up, its worth clarifying the order members by their access modifier from most accessible to least accessible:</p>

<ol>
    <li><code>public</code> - Accessible by any code</li>
    <li><code>protected</code> - Accessible by the class and its subclasses</li>
    <li><code>internal</code> - Accessible within the same assembly</li>
    <li><code>protected internal</code> - Accessible by the assembly or derived classes</li>
    <li><code>private protected</code> - Accessible by derived classes within the same assembly</li>
    <li><code>private</code> - Accessible only within the declaring class</li>
</ol>

<p>Hopefully this helps make things a little clearer than before!</p>
</body>
</html>
