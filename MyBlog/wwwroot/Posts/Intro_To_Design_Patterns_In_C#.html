<!-- PublishedDate: 2025-04-21 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: auto;
            padding: 2rem;
            line-height: 1.6;
            background: #f9f9f9;
            color: #333;
        }
        h1, h2 {
            color: #222;
        }
        pre {
            background: #eee;
            padding: 1rem;
            overflow-x: auto;
        }
        code {
            font-family: monospace;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .tip {
            background: #e7f3ff;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
<h1>Intro to Design Patterns in C#</h1>

<p>Straight away I didn‚Äôt know design patterns are actually grouped into three categories:</p>

<ul>
    <li><strong>Creational</strong> ‚Äì Creating objects (e.g. Singleton, Factory)</li>
    <li><strong>Structural</strong> ‚Äì Composing objects and classes (e.g. Adapter, Decorator)</li>
    <li><strong>Behavioural</strong> ‚Äì Managing object interaction and communication (e.g. Observer)</li>
</ul>

<h2 class="mt-4">üß± Creational Patterns</h2>

<h4>Singleton</h4>
<p>
    Ensures a class has only one instance and provides global access to it. Often used for logging, config, or data connections.
    You make the constructor private so new instances can't be created directly. Instead, a property manages the instance creation,
    checking if one already exists. To make it thread-safe, use a <code>readonly</code> lock object and wrap access in a <code>lock</code> block.
</p>

<h4>Factory</h4>
<p>
    Hides the creation logic of objects. You create multiple implementations of an interface, then use a Factory to return the right one
    depending on conditions (like a <code>switch</code>). This means consumers don‚Äôt need to worry about how the object is created.
</p>
<p>
    I saw Carl do this with an Entities Factory that returns impersonated or non-impersonated clients. Very cool ‚Äî keeps consuming code clean.
</p>

<h2 class="mt-4">üèóÔ∏è Structural Patterns</h2>

<h4>Adapter</h4>
<p>
    Lets you adapt an existing class to a new interface ‚Äî perfect when you have legacy code (e.g. old logger) that doesn‚Äôt match your
    current system's expected interface. The Adapter class bridges that gap.
</p>

<h4>Decorator</h4>
<p>
    Adds new behaviour to an object without changing its core logic. You use an abstract decorator class that implements the same interface
    as the object, pass the original object into it, and then override methods to enhance or change behaviour ‚Äî like adding extra text to a log.
</p>

<h2 class="mt-4">üß† Behavioural Patterns</h2>

<h4>Observer</h4>
<p>
    Automatically reacts to changes in another object. The pattern uses a <strong>Subject</strong> that holds a list of <strong>Observers</strong>.
    Observers can be added/removed, and when the subject's state changes, it notifies all observers to react. This reminded me of delegates ‚Äî
    that automatic action triggering was very cool.
</p>
</body>
</html>
