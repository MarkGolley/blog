<!-- PublishedDate: 2025-04-28 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: system-ui, sans-serif;
            max-width: 800px;
            margin: auto;
            padding: 2rem;
            line-height: 1.6;
            background: #f9f9f9;
            color: #333;
        }
        h1, h2 {
            color: #222;
        }
        pre {
            background: #eee;
            padding: 1rem;
            overflow-x: auto;
        }
        code {
            font-family: monospace;
        }
        a {
            color: #0366d6;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .tip {
            background: #e7f3ff;
            border-left: 4px solid #2196f3;
            padding: 1rem;
            margin: 1rem 0;
        }
    </style>
</head>
<body>
<h1>Design Patterns Part 2</h1>

<h4>Repository</h4>
<p>
    This was interesting as I can see that you can create the repository you need to interact with and then put in place an interface
    to require the repository and methods to interact with it, such as adding or finding. You can then create a concrete class which
    implements all of this and, using dependency injection, instantiate the class. Now the service can interact with the data with the
    details abstracted away — and I think that means you can have different implementations for different databases?
</p>

<h4>Strategy</h4>
<p>
    This was really interesting — it’s a pattern where you provide behavior by injecting the class with the desired behavior.
    The example I saw was where a payment service needs to handle different payment types. They created an interface that simply
    defines a method like <code>Pay()</code>, then created several implementations (e.g. PayPal, Apple Pay, etc.).
    When constructing the service, you pass in the strategy class you want, so when the service calls <code>Pay()</code>, it uses
    the correct implementation. It seemed cool for cases where the same action occurs in different ways — you just swap in the strategy.
    It suggested that if you find yourself writing a lot of <code>if</code> statements to vary behavior, maybe a strategy pattern
    would be better.
</p>

<h3 class="mt-4">KATA Learnings</h3>

<h4>StringBuilder</h4>
<p>
    This is a faster way to build strings, since concatenation creates a new string each time.
    I’ve seen <code>StringBuilder</code> before but hadn’t looked into it. I liked how you can use <code>Append()</code>
    to add more text (there are other methods too like <code>Clear()</code> and <code>Replace()</code>).
    It feels nicer than using <code>+=</code>. I also read that in short or simple cases, regular concatenation
    is fine — but for more complex string operations, <code>StringBuilder</code> is more performant.
</p>

<h4>Char vs String</h4>
<p>
    I never knew that <code>'A'</code> is a <strong>char</strong> and <code>"A"</code> is a <strong>string</strong>.
    So if you use <code>"A"</code>, that’s already a string — not a character. I think I didn’t know this
    because in Python and JavaScript (where I started), there’s no difference between <code>"</code> and <code>'</code> — they’re both strings.
    I’ll definitely be more mindful of that distinction in C# now.
</p>
</body>
</html>